#include <SPI.h>
#include <RFID.h>
#include <EEPROM.h>
#include <SolenoidLock.h>

#define SS_PIN 53
#define RST_PIN 10
#define SOLENOIDLOCK_PIN_GND 12

SolenoidLock solenoidLock(SOLENOIDLOCK_PIN_GND);
byte cur_badge[5];

RFID rfid(SS_PIN, RST_PIN);

void setup()
{
  Serial.begin(9600);
  SPI.begin();
  rfid.init();
}

void remove_badge()
{
  // Retire le badge actuel de la liste des badges autorisés stockés dans l'EEPROM
  int nb_badges = EEPROM.read(0); //Lit le numéro des badges stockés and l'EEPROM
  int badge_index = -1; // Index du badge à retirer (-1 si aucun badge n'est trouvé)
 
  // Recherche un badge dans l'EEPROM
  for(int i = 0; i < nb_badges; i++)
  {
    if(EEPROM.read(i * 5 + 1) == cur_badge[0] &&
       EEPROM.read(i * 5 + 2) == cur_badge[1] &&
       EEPROM.read(i * 5 + 3) == cur_badge[2] &&
       EEPROM.read(i * 5 + 4) == cur_badge[3] &&
       EEPROM.read(i * 5 + 5) == cur_badge[4])
    {
      badge_index = i;
      break;
    }
  }
 
  // Si le badge est détecté, le retirer de l'EEPROM
  if(badge_index >= 0)
  {
    for(int i = badge_index; i < nb_badges - 1; i++)
    {
      EEPROM.write(i * 5 + 1, EEPROM.read(i * 5 + 6));
      EEPROM.write(i * 5 + 2, EEPROM.read(i * 5 + 7));
      EEPROM.write(i * 5 + 3, EEPROM.read(i * 5 + 8));
      EEPROM.write(i * 5 + 4, EEPROM.read(i * 5 + 9));
      EEPROM.write(i * 5 + 5, EEPROM.read(i * 5 + 10));
    }
    EEPROM.write(0, nb_badges - 1); // Mise à jour du numéro des badges stockés dans l'EEPROM
  }
}

void add_badge()
{
  // Ajoute le badge actuel dans la liste des badges autorisés stockés dans l'EEPROM
  int nb_badges = EEPROM.read(0); // Lecture du numéro des badges stockés dans l'EEPROM
  int start_mem = nb_badges * 5 + 1; // Calcule l'endroit en mémoire où le badge sera stocké
 
  // Stocke le badge dans l'EEPROM
  for(byte i = 0; i < 5; i++)
  {
    EEPROM.write(start_mem + i, cur_badge[i]);
  }
  EEPROM.write(0, nb_badges + 1); // Mise à jour du numéro des badges stockés dans l'EEPROM
}

bool compare_badge()
{
  // Compare le badge actuel dans la liste des badges autorisés stockés dans l'EEPROM
  int nb_badges = EEPROM.read(0); // Lecture du numéro des badges stockés dans l'EEPROM
  bool badge_ok = false; // Met à 0 si aucun badge n'est détecté dans la liste des badges autorisés
 
  // Search for the badge in the EEPROM
  for(int i = 0; i < nb_badges; i++)
  {
    if(EEPROM.read(i * 5 + 1) == cur_badge[0] &&
       EEPROM.read(i * 5 + 2) == cur_badge[1] &&
       EEPROM.read(i * 5 + 3) == cur_badge[2] &&
       EEPROM.read(i * 5 + 4) == cur_badge[3] &&
       EEPROM.read(i * 5 + 5) == cur_badge[4])
    {
      badge_ok = true;
      break;
    }
  }
 
  return badge_ok;
}

void loop()
{
  if (rfid.isCard()) // Wait for a badge to be presented to the reader
  {
    if (rfid.readCardSerial())
    {
      for(int i = 0; i < 5; i++)
      {
        cur_badge[i] = rfid.serNum[i]; // Read the serial number of the badge
      }
     
      if(compare_badge()) // Check if the badge is allowed to unlock the lock
      {
        solenoidLock.on(); // Unlock the lock
        delay(1000); // Leave the lock unlocked for 1 second
        solenoidLock.off(); // Lock the lock again
        remove_badge(); // Remove the badge from the list of allowed badges
        Serial.println("Unlocked and removed");
        delay(1000);
      }
      else
      {
        Serial.println("Not recognized");
        delay(1000);
      }
    }
  }
 
  if(Serial.available() > 0) // Check if a key has been pressed on the keyboard
  {
    char key = Serial.read(); // Read the key that was pressed
    if(key == '1') // If the key is "1", add the current badge to the list of allowed badges
    {
      add_badge();
      Serial.println("Badge added");
      delay(1000);
    }
  }
 
  rfid.halt();
}
